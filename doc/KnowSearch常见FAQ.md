# 1.索引相关知识

## 1.1 appid应用级别限流和查询模板级别限流的是什么？

appid 应用级别限流是针对整个应用每秒最多能查询多少次，如果触发到appid应用级别限流，会接收到 FlowLimitException 错误。查询模板级别限流是针对相同结构的查询语句每秒最多能查询多少次，如果触发到查询模板级别限流，会接收到 DslRateLimitException 错误，这里的限流值GateWay单实例生效。

## 1.2 为什么多type方式被移除？

最初，我们谈到“索引”类似于SQL数据库中的“数据库”，“类型”等同于“表”。这是一个错误的类比，导致了错误的假设。在SQL数据库中，表是相互独立的。一个表中的列与另一个表中同名的列没有关系，相同列名的数据类型可以不同。在 Elasticsearch 索引中，在不同映射类型中具有相同名称的字段在内部由相同的 Lucene 字段支持。换句话说，相同字段名在不同type中必须具有相同的映射（定义）。除此之外，在同一索引中存储相同字段很少或没有字段的不同实体会导致数据稀疏，并干扰 Lucene 高效压缩文档的能力。不同 type 的数据存储在相同的 Lucene 文件中。

## 1.3 mapping是什么？

- mapping是Lucence存储与索引字段的方式和规则，如某个字段的数据类型、默认值、分析器、是否被索引等。
- 参考官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/master/mapping.html

## 1.4 数据已经接放ES，现在想增加一些新的字段 ，该怎么做？

ES 会动态判断该字段类型并建立索引，并且会按照该字段首次出现的类型来定义该字段。例如: 新增字段 {"name":"dididatabus"} es会判断为 string 类型。

## 1.5 时间字段起到什么作用？

时间字段主要用于时间分区的作用，为了防止索引膨胀，ES 会根据时间字段写入索引名称，分区主要有按天、按月两种，例如（indexname_2018-08-08、indexname_201808），默认情况下保存天数超过一个月会按月建立索引，其它时间会按天进行建立。



# 2.查询相关问题

## 2.1 DSL查询语法如何编写？

参考官网手册：https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html

## 2.2 为什么不能查询排序在10000条以后的数据？

很多用户都有疑问，ES 为什么不能查询 10000 条之后的数据。了解这个问题需要了解到es的分布式原理。ES 一个索引是对应到多个shard（数据分片），对于带size的查询，es是在每个shard上都会返回size条数据，如果索引有 100 个 shard，那就是得先汇聚 100*size 条数据，然后再排序选出size条数据。所以分页太深，ES 汇聚的数据量太大，会导致 ES 节点不堪重负。如果用户想查看深分页的数据，有两种方式，一种是带上 where 条件，让10000条之后的数据能通过查询条件，在前面被查出来。另一种是针对获取大量数据的场景，使用 ES 的 scroll 方式，可以批量捞取全量的数据。不过官方不再建议使用scroll API进行深度分页。如果要分页检索超过 Top 10,000+ 结果时，推荐使用：PIT + search_after。

## 2.3 如何通过scroll方式获取全量的查询结果？

- ES 通过 scroll 的方式获取全量的数据，scroll 的原理是在每个 shard 上保存上次查询的 offset，这样可以直接基于 offset 去往下查询。
- scroll 的文档见：https://www.elastic.co/guide/en/elasticsearch/reference/master/paginate-search-results.html#scroll-search-results

## 2.4 关于分页查询

### 2.4.1 主要有三种分页查询方式

- From + Size 查询：优点是支持随机翻页，受制于 max_result_window 设置，不能无限制翻页，存在深度翻页问题，越往后翻页越慢，深分页不推荐使用；
- Search After 查询：查询本质是使用前一页中的一组排序值来检索匹配的下一页，并且不严格受制于 max_result_window，可以无限制往后翻页，但是不支持随机翻页；
- Scroll 查询：相比于 From + Size 和 search_after 返回一页数据，Scroll API 可用于从单个搜索请求中检索大量结果（甚至所有结果），其方式与传统数据库中游标（cursor）类似，支持全量遍历，但是响应时间是非实时 ，并且保留上下文需要足够的堆内存空间。

### 2.4.2 分别的使用场景

- From + Size 查询：非常适合小型数据集或者大数据集返回 Top N（N <= 10000）结果集的业务场景，支持随机跳转分页的业务场景；

- Search After 查询：不支持随机翻页，更适合手机端应用的场景（一直往下滑动刷新数据的场景）；

- Scroll 查询：全量或数据量很大时遍历结果数据，而非分页查询，并且对实时性要求不高的场景。关于具体的使用方式请见官方文档。

